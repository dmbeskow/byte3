#source ./eb-dash2/bin/activate

import dash
from dash.dependencies import Input, Output
import dash_core_components as dcc
import dash_html_components as html
import plotly.graph_objs as go
from pandas_datareader import data as web
import pandas as pd
from datetime import datetime as dt
import datetime as dt
import os
import json
import dateutil

app = dash.Dash(__name__)
application = app.server


def convert_date(series):
    newlist = []
    mylist=series.tolist()
    for element in mylist:
        newlist.append(dateutil.parser.parse(element))
    return(newlist)


def get_files(word = 'activity'):
    f = os.listdir('.')
    files = []
    for file in f:
        if word in file:
            files.append(file)
    return(files)

def generate_table(dataframe, max_rows=10):
    return html.Table(
        # Header
        [html.Tr([html.Th(col) for col in dataframe.columns])] +

        # Body
        [html.Tr([
            html.Td(dataframe.iloc[i][col]) for col in dataframe.columns
        ]) for i in range(min(len(dataframe), max_rows))]
    )
datasets = pd.DataFrame({
    "Data": ['Heart Rate', 'Sleep Data', 'Distance', 'Steps','Floors','Food','Calories'],
    "Description": [
    'Minute time series data to document heart Rate',
    'Minute time series data documents sleep (if asleep, how deep that sleep is.)',
    'Minute time series data for distance traveled',
    'Minute time series data for steps taken',
    'Minute time series data for floors climbed',
    'Summary of daily food intake',
    'Minute time series data for Calories burned'
    ]
})

act = pd.read_csv('activities_total.csv')

markdown_text1 = '''
### About this Data

In lieu of using the AWARE app to collect data for Interactive Data Science "Byte 3",
I've developed this app using Fitbit data that documents numerous measurements taken 24 hours a day for the past 10 days.  By using Fitbit Data, I am staying within the intent that this 'byte' should be related to the 'ubiquitous self' concept.  (Note that Professor Stamper knows about this modification of the original guidance for Byte3. )

Fitbit allows access to personal data related to heart rate, sleep activity, excercise, caloric intake, steps taken, floors climbed, and distance traveled.

The Fitbit Data was generated by a Fitbit Blaze smartwatch that I wear almost all of the time. I accessed the Fitbit data through the Fitbit API.  I used the [Python Fitbit package](https://pypi.python.org/pypi/fitbit/0.1.3) to facilitate this.  Through this package I was able to collect the following data sets:

-----

'''

markdown_text1_5 = '''
## Data Quality:

The Fitbit API returns very detailed data in JSON format.  For most the the data that I scraped using the API, I was able to get time series data at minute level, with metadata included to provide daily summaries.

While the data that is returned is clean and always formatted the same, any user of this app should realize that Fitbit data inherently comes with user error and device error.  In my case, user error occurred when I took the watch off, or forgot to charge the battery.  Additionally, the heart rate data will be less accurate if I do not fasten the watch securely to my wrist. Device error is also present since any device does not measure events perfectly. Fitbit device error particularly occurs when measuring  steps, distance, and heart rate.  I've found that at times my step count will grow if I'm driving over rougher roads, or doing some other activity that is jarring the device in a similar manner to walking.  Additionally, some of the variance in the heart rate is due to imperfect measurement or imperfect contact with my wrist.

------
'''



markdown_text2 = '''
## Fitbit Exploratory Data Analysis

In this app I will explore personal Fitbit data in order to answer questions about my personal health as well as to evaluate the accuracy of the Fitbit monitoring system.

-----
### Analysis of *Distance* and *Step* Data:

Below the user can input a date (must be between `2018-02-16` and `2018-03-01`) and then view the daily cumulative summation of distance and step data.  Note that common sense tells us that this data should be highly correlated.


'''



markdown_sleep = '''
-----

### Analysis of *Sleep* data:

Below is a heatmap of sleep activity.  `Red` represents time when I was awake, `blue` represents times when I was asleep, and `white` represents times when my sleep was *restless*.
'''

markdown_HR = '''
-----

### Analysis of *Heart Rate* data:

Below is a time series plot of my heart rate activity.  You can clearly delineate times of activity from times of sleep.  Note that this graph is zoomable.
'''

markdown_table = '''
-----

### Table of daily data:

Below is a summary table of daily activity:
'''

"""
algorithm for cleaning and presenting heart rate data
"""
Date = []
time = []
value = []
f = get_files('HR_')
for file in f:
    infile = open(file, 'r')
    temp = json.load(infile)
    d = temp['activities-heart'][0]['dateTime']
    for i in temp['activities-heart-intraday']['dataset']:
        Date.append(d)
        value.append(i['value'])
        time.append(i['time'])


HR_df = pd.DataFrame({'Date':Date,'HR':value,'Time':time})
HR_df['dateTime'] = HR_df['Date'] + ' ' +  HR_df['Time']


HR_df.index = convert_date(HR_df['dateTime'])
HR_df = HR_df.resample('10T').mean()

slp_matrix = pd.read_csv('slp_matrix.csv')
slp_matrix.index = slp_matrix.Date
slp_matrix = slp_matrix.drop(['Date'], axis = 1)

app.layout = html.Div([
    html.Div([
        html.Div([
            dcc.Markdown(children=markdown_text2),
            dcc.Input(
                id='startdate-input',
                type='date',
                value = dt.date(2018,2, 22)
#                value=dt.date.today() - dt.timedelta(days=4)
            ),
            # dcc.Dropdown(
            #     id='my-dropdown',
            #     options=[
            #         {'label': 'Coke', 'value': 'COKE'},
            #         {'label': 'Tesla', 'value': 'TSLA'},
            #         {'label': 'Apple', 'value': 'AAPL'}
            #     ],
            #     value='COKE'
            # ),
            dcc.Graph(id='my-graph'),
            dcc.Graph(id='my-graph2'),
            dcc.Markdown(children=markdown_sleep),
           dcc.Graph(
                id='heatmap',
                figure = {
                    'data':[
                        go.Heatmap(z = slp_matrix.values.tolist(),
                                    y = list(slp_matrix.index),
                                    x = list(slp_matrix))
                            ],
                    'layout': {
                        'title': 'Heatmap of Sleep Activity'
                        }
                    }
            ),
           dcc.Markdown(children=markdown_HR),
           dcc.Graph(
                id='example-graph',
                figure={
                    'data': [{
                        'x': HR_df.index,
                        'y': HR_df.HR
                    }],
                    'layout': {
                        'title': 'Average Heart Rate (10 min interval)'
                    }
                }
            ),
            dcc.Markdown(children=markdown_table),
            generate_table(act),
        ], className="eight columns"),

        html.Div([
            dcc.Markdown(children=markdown_text1),
            generate_table(datasets),
            dcc.Markdown(children=markdown_text1_5)
        ], className="four columns"),
    ], className="row")
])

app.css.append_css({
    'external_url': 'https://codepen.io/chriddyp/pen/bWLwgP.css'
})

@app.callback(Output('my-graph', 'figure'), [Input('startdate-input', 'value')])
def update_graph(selected_startdate_input):
    Date = []
    time = []
    value = []
    f = get_files('distance')
    for file in f:
        infile = open(file, 'r')
        distance = json.load(infile)
        d = distance['activities-distance'][0]['dateTime']
        for i in distance['activities-distance-intraday']['dataset']:
            Date.append(d)
            value.append(i['value'])
            time.append(i['time'])
    distdf = pd.DataFrame({'Date':Date,'Distance':value,'Time':time})
    distdf['dateTime'] = distdf['Date'] + ' ' +  distdf['Time']
    print(selected_startdate_input)
    cs = distdf[distdf['Date']== selected_startdate_input]
    cs.index = convert_date(cs['dateTime'])
    cs = cs.resample('10T').sum()
    cs = cs.cumsum()
    return {
        'data': [{
            'x': cs.index,
            'y': cs.Distance
        }],
        'layout': {
                'title': 'Cumulative Daily Distance'
            }
    }
@app.callback(Output('my-graph2', 'figure'), [Input('startdate-input', 'value')])
def update_steps(selected_startdate_input):
    Date = []
    time = []
    value = []
    f = get_files('step')
    for file in f:
        infile = open(file, 'r')
        distance = json.load(infile)
        d = distance['activities-steps'][0]['dateTime']
        for i in distance['activities-steps-intraday']['dataset']:
            Date.append(d)
            value.append(i['value'])
            time.append(i['time'])
    distdf = pd.DataFrame({'Date':Date,'Steps':value,'Time':time})
    distdf['dateTime'] = distdf['Date'] + ' ' +  distdf['Time']
    print(selected_startdate_input)
    cs = distdf[distdf['Date']== selected_startdate_input]
    cs.index = convert_date(cs['dateTime'])
    cs = cs.resample('10T').sum()
    cs = cs.cumsum()
    return {
        'data': [{
            'x': cs.index,
            'y': cs.Steps
        }],
        'layout': {
                'title': 'Cumulative Daily Steps'
            }
    }

# @app.callback(Output('my-graph', 'figure'), [Input('my-dropdown', 'value')])
# def update_graph(selected_dropdown_value):
#     df = web.DataReader(
#         selected_dropdown_value, data_source='google',
#         start=dt(2017, 1, 1), end=dt.now())
#     return {
#         'data': [{
#             'x': df.index,
#             'y': df.Close
#         }]
#     }

if __name__ == '__main__':
    # app.run_server(debug = True)
    application.debug = True
    application.run()
